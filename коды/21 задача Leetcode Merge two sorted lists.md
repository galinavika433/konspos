#Python #code
```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        
        dummy = ListNode()
        last = dummy

        while list1 and list2:
            if list1.val < list2.val:
                last.next = list1
                list1 = list1.next
            else:
                last.next = list2
                list2 = list2.next
            
            last = last.next

        last.next = list1 or list2

        return dummy.next
```

## Объяснение задачи
У нас есть два списка. Сначала записывается 1 значение первого списка. Перед тем, как перейти на следующий элемент первого списка, смотрим на второй список. Если второе значение первого списка больше первого значения второго, то сначала записываем значение 2 списка, затем значение первого списка и т.д.

## Объяснение кода
### Шаг 1: Инициализация фиктивного узла (Dummy) и указателя последнего элемента (Last Pointer)
   ```python
dummy = ListNode()
last = dummy
   ```

 Сначала я создал фиктивный узел (`dummy`) с помощью `ListNode()`. Этот узел не будет содержать полезных данных и будет служить заглушкой или начальной точкой для нового объединенного списка. Затем  создал указатель `last` и инициализировал его значением `dummy`. Указатель `last` всегда будет указывать на последний узел в нашем строящемся объединенном списке. Это позволяет нам эффективно добавлять новые узлы, используя `last.next = новый_узел`. Объединенный список на данный момент пуст, его "голова" находится сразу после dummy.

### Шаг 2: Итеративное слияние списков
```python
while list1 and list2:
            if list1.val < list2.val:
                last.next = list1
                list1 = list1.next
            else:
                last.next = list2
                list2 = list2.next
            
            last = last.next
```

Я запустил цикл while, который продолжается, пока оба списка (`list1 и list2`) не станут пустыми (`None`). Внутри цикла я сравнил значения (`val`) текущих узлов в `list1` и `list2`. Если `list1.val` меньше `(list1.val < list2.val)`, я присоединил текущий узел из `list1` к объединенному списку: `last.next = list1`. Затем я переместил указатель `list1` на следующий узел в его исходном списке: `list1 = list1.next`. Если `list2.val` меньше или равно, я сделал то же самое, но для `list2: last.next = list2`, а затем `list2 = list2.next`. Перемещение указателя `last`: Вне зависимости от того, какой узел был присоединен, я переместил указатель `last` на только что присоединенный узел: `last = last.next`. Это гарантирует, что `last` всегда готов принять следующий, меньший элемент. В конце каждой итерации наименьший из двух текущих узлов перемещается из одного из исходных списков в объединенный список, сохраняя его отсортированность.

### Шаг 3: Присоединение остатка
```python
last.next = list1 or list2
```

Когда цикл `while` завершился (в Шаге 2), это означает, что как минимум один из списков (`list1` или `list2`) стал пустым (`None`). Я использовал логическое выражение `list1 or list2`. Если `list1` содержит оставшиеся узлы (он не `None`), выражение возвращает `list1`. Если `list1` пуст (`None`), то выражение возвращает `list2` (который может быть пустым или содержать остатки). Поскольку исходные списки отсортированы, все оставшиеся узлы в непустом списке уже больше, чем все узлы в объединенном списке. Я присоединил этот оставшийся (или пустой) список целиком к концу объединенного списка: `last.next = (остаток)`. В итоге, все узлы из обоих исходных списков теперь находятся в объединенном списке.

### Шаг 4: Возврат результата (Return Value)
```python
return dummy.next
```

Я вернул следующий узел после фиктивного узла: `dummy.next`. Почему не `dummy`? Потому что `dummy` — это просто заглушка, которую мы использовали для удобного начала построения списка. Фактический, первый элемент отсортированного объединенного списка всегда находится по адресу `dummy.next`. Результат: Функция возвращает указатель на голову нового, полностью объединенного и отсортированного односвязного списка.